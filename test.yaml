---
- name: Determine PV Device Path using SCSI ID
  hosts: debian_servers
  gather_facts: false
  vars:
    prefix: "scsi-0QEMU_QEMU_HARDDISK_drive-"

  tasks:
    - name: Construct full SCSI device ID
      set_fact:
        full_scsi_id: "{{ prefix + 'scsi1' }}"  # scsi_ID_info has fetched from main.yaml in root directory.

    - name: Get symlink target for full SCSI ID
      stat:
        path: "/dev/disk/by-id/{{ full_scsi_id }}"
      register: scsi_stat


    - name: Find all LVM PV UUID symlinks  # Check Point 2: Check if there is a VG to which the disk belongs
      find:
        paths: /dev/disk/by-id
        patterns: "lvm-pv-uuid-*"
        file_type: link
      register: pv_links

    - name: Get stats for PV symlinks
      stat:
        path: "{{ item.path }}"
      register: pv_stats
      loop: "{{ pv_links.files }}"

    - name: Set PV device path fact and PV UUID fact (which is to validate the correctness of the pv in next steps)
      set_fact:
        pv_tag: "/dev/{{ item.stat.lnk_target | basename }}"
        pv_uuid: "{{ item.item.path | basename | replace('lvm-pv-uuid-', '') }}"
      loop: "{{ pv_stats.results }}"
      when: item.stat.lnk_target == scsi_stat.stat.lnk_target

    # - name: Set PV device path fact
    #   set_fact:
    #     pv_tag: "/dev/{{ item.stat.lnk_target | basename }}"
    #   loop: "{{ pv_stats.results }}"
    #   when: item.stat.lnk_target == scsi_stat.stat.lnk_target

    - name: Print PV device path
      debug:
        var: pv_tag


    - name: Get features of physical volume to use in comparement of UUID & scsi1 and in extracting some information (like vg_name, uuid)
      command: "pvdisplay -c {{ pv_tag }}"
      register: pv_features

    # # Alternative : Get UUID Info. for the PV for next steps
    # - name: Get UUID Information
    #   set_fact:
    #     pv_uuid: "{{ pv_features.stdout.split(':')[11] }}"


    # ----- End for Step 1 -----



    # Step 2: Extend the Physical Volume
    - name: Resize PV
      command: "pvresize {{ pv_tag }}"
      ignore_errors: yes # Continue even if this task fails

    # ----- End for Step 2 -----



    # Step 3: Get VG Name Information
    - name: Get features of physical volume
      command: "pvdisplay -c {{ pv_tag }}"
      register: pv_features

    - name: Extract the VG Name info
      set_fact:
        vg_name: "{{ pv_features.stdout.split(':')[1] | trim }}"

    - name: Display volume group name
      debug:
        var: vg_name

    # ----- End for Step 3 -----



    # Step 4: Extend Logical Volume and Resize its filesystem
    - name: Check if VG exists and get LVs using lvs command
      command: lvs --noheadings -o lv_name,vg_name --select vg_name={{ vg_name }}
      register: lvs_result
      changed_when: false
      ignore_errors: yes

    - name: Parse LV names from command output
      set_fact:
        lv_list: "{{ lvs_result.stdout_lines | map('trim') | map('split', ' ') | map('first') | list }}"
      when: not lvs_result.failed and lvs_result.stdout | trim | length > 0

    - name: Set empty list if command failed
      set_fact:
        lv_list: []
      when: lvs_result.failed or lvs_result.stdout | trim | length == 0

    - name: Display LV list
      debug:
        msg: "LVs in VG {{ vg_name }}: {{ lv_list }}"

    - name: Set LV name if LVs exist
      set_fact:
        lv_name: "{{ lv_list[0] }}"
      when: lv_list | length > 0

    - name: Display LV name
      debug:
        msg: "First LV name: {{ lv_name }}"


    - name: Extend LV and resize filesystem
      community.general.lvol:
        vg: "{{ vg_name}}"
        lv: "{{ lv_name }}"
        size: +100%FREE
        resizefs: true # This will resize the filesystem 
        state: present

    # ----- End for Step 4 -----
  

  